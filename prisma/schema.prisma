// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBRE
  INVITE
  PRESID
  VICEPR
  SECRET
  VICESE
  COMCPT
  TRESOR
  VTRESO
}

enum MenuRole {
  ADMIN // Administrateur
  PRESID // Président
  VICEPR // Vice-Président
  SECRET // Secrétaire
  VICESE // Vice-Secrétaire
  COMCPT // Comptable/Trésorier
  TRESOR // Trésorier
  VTRESO // Vice-Trésorier
  MEMBRE // Membre simple
  INVITE // Invité
  VISITEUR // Visiteur non connecté
}

// Rôles d'administration (peut être attribué plusieurs fois à un utilisateur)
// Note: MEMBRE est géré par UserRole.MEMBRE, pas besoin de le dupliquer ici
enum AdminRole {
  ADMIN // Administrateur - a tous les droits
  PRESID // Président - peut tout voir mais ne peut pas tout modifier
  VICEPR // Vice-Président - peut tout voir mais ne peut pas tout modifier
  SECRET // Secrétaire - peut tout voir mais ne peut pas tout modifier
  VICESE // Vice-Secrétaire - peut tout voir mais ne peut pas tout modifier
  TRESOR // Trésorier - peut tout voir mais ne peut pas tout modifier
  VTRESO // Vice-Trésorier - peut tout voir mais ne peut pas tout modifier
  COMCPT // Comptable/Trésorier - peut tout voir mais ne peut pas tout modifier
}

enum MenuNiveau {
  NAVBAR // 0 - Menu dans la barre de navigation
  SIDEBAR // 1 - Menu dans le menu latéral
}

enum UserStatus {
  Actif
  Inactif
}

enum Civilities {
  Monsieur
  Madame
  Mademoiselle
  Partenaire
}

enum TypeAdhesion {
  AdhesionAnnuelle
  Renouvellement
  Autre
}

enum TypeEvenementFamilial {
  Naissance
  MariageEnfant
  DecesFamille
  AnniversaireSalle
  Autre
}

enum TypeCotisation {
  Forfait
  Assistance
  Anniversaire
  Adhesion
}

/// Catégorie du type de cotisation mensuelle : forfait mensuel (obligatoire), assistance (bénéficiaire), ou divers/extra
enum CategorieTypeCotisation {
  ForfaitMensuel // Cotisation forfait mensuelle obligatoire (une par mois)
  Assistance     // Cotisation type assistance : naissance, décès, mariage, anniversaire (bénéficiaire)
  Divers         // Cotisation diverse / extra : formation, matériel, etc.
}

enum MoyenPaiement {
  Especes
  Cheque
  Virement
  CarteBancaire
  Stripe
  PayPal
  GooglePay
}

enum TypeTelephone {
  Mobile
  Fixe
  Professionnel
}

enum StatutRelance {
  EnAttente
  Envoyee
  Relancee
  Payee
  Annulee
}

enum TypeRelance {
  Email
  SMS
  Telephone
  Courrier
  Visite
}

enum ElectionStatus {
  Preparation
  Ouverte
  Cloturee
  Annulee
}

enum PositionType {
  President
  VicePresident
  Secretaire
  ViceSecretaire
  Tresorier
  ViceTresorier
  CommissaireComptes
  MembreComiteDirecteur
}

// Modèle pour historiser les postes électoraux
model PosteTemplate {
  id          String  @id @default(cuid())
  code        String  @unique @db.VarChar(6) // Code unique de 6 caractères généré automatiquement
  libelle     String  @db.VarChar(255) // Libellé français (ex: "Président")
  description String? @db.Text // Description du poste
  ordre       Int     @default(0) // Ordre d'affichage
  actif       Boolean @default(true) // Si le poste est actif (peut être utilisé)

  // Valeurs par défaut pour ce type de poste
  nombreMandatsDefaut Int  @default(1)
  dureeMandatDefaut   Int? // Durée en mois

  // Relations
  positions Position[] // Positions utilisant ce template
  adherents Adherent[] // Adhérents ayant ce poste

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String // ID de l'utilisateur qui a créé le poste
  CreatedBy User     @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@map("postes_templates")
}

enum CandidacyStatus {
  EnAttente
  Validee
  Rejetee
  Retiree
}

enum VoteStatus {
  Valide
  Invalide
  Blanc
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                            String                       @id @default(cuid())
  name                          String?                      @unique
  email                         String?                      @unique
  emailVerified                 DateTime?                    @map("email_verified")
  password                      String?
  image                         String?
  accounts                      Account[]
  sessions                      Session[]
  adherent                      Adherent?
  role                          UserRole                     @default(MEMBRE)
  status                        UserStatus                   @default(Inactif)
  depenses                      Depense[]                    @relation("DepenseCreatedBy") // Relation avec les dépenses créées
  depensesValidees              Depense[]                    @relation("DepenseValidatedBy") // Relation avec les dépenses validées
  typesDepenseCrees             TypeDepense[]                @relation("TypeDepenseCreatedBy") // Types de dépense créés
  justificatifsUploades         JustificatifDepense[]        @relation("JustificatifUploadedBy") // Justificatifs uploadés
  typesCotisationMensuelle      TypeCotisationMensuelle[] // Types de cotisation créés
  cotisationsDuMoisCreees       CotisationDuMois[]           @relation("CotisationDuMoisCreatedBy") // Cotisations du mois créées
  cotisationsMensuelles         CotisationMensuelle[] // Cotisations mensuelles créées
  relancesCotisationMensuelle   RelanceCotisationMensuelle[] // Relances créées
  dettesInitialesCreees         DetteInitiale[]              @relation("DetteInitialeCreatedBy") // Dettes initiales créées
  paiementsCreees               PaiementCotisation[]         @relation("PaiementCreatedBy") // Paiements créés
  assistancesCreees             Assistance[]                 @relation("AssistanceCreatedBy") // Assistances créées
  evenements                    Evenement[] // Événements créés
  conversations                 Conversation[] // Conversations créées
  conversationParticipants      ConversationParticipant[] // Participations aux conversations
  messages                      Message[] // Messages envoyés
  postesTemplates               PosteTemplate[] // Postes créés
  messageReactions              MessageReaction[] // Réactions aux messages
  configurationsFraisAdhesion   ConfigurationFraisAdhesion[] @relation("ConfigurationFraisAdhesionCreatedBy") // Configurations de frais d'adhésion créées
  adminRoles                    UserAdminRole[]              @relation("UserAdminRoles") // Rôles d'administration de l'utilisateur
  adminRolesAttributed          UserAdminRole[]              @relation("UserAdminRoleCreator") // Rôles d'administration attribués par cet utilisateur
  notifications                 Notification[] // Notifications reçues
  emailsReceived                Email[]                      @relation("EmailRecipient") // Emails reçus
  emailsSent                    Email[]                      @relation("EmailCreatedBy") // Emails envoyés
  suppressionsEffectuees        SuppressionAdherent[]        @relation("SuppressionDeletedBy") // Suppressions d'adhérents effectuées
  dataDeletionRequests          DataDeletionRequest[]        @relation("DataDeletionRequestUser") // Demandes de suppression de données
  dataDeletionRequestsVerified  DataDeletionRequest[]        @relation("DataDeletionRequestVerifiedBy") // Demandes vérifiées
  dataDeletionRequestsApproved  DataDeletionRequest[]        @relation("DataDeletionRequestApprovedBy") // Demandes approuvées
  dataDeletionRequestsRejected  DataDeletionRequest[]        @relation("DataDeletionRequestRejectedBy") // Demandes rejetées
  dataDeletionRequestsCompleted DataDeletionRequest[]        @relation("DataDeletionRequestCompletedBy") // Demandes complétées
  documents                     Document[] // Documents uploadés
  badgesAttribues               BadgeAttribution[] // Badges attribués à cet utilisateur
  ressourcesCreees              Ressource[]                  @relation("RessourceCreatedBy") // Ressources créées
  reservationsConfirmees        Reservation[]                @relation("ReservationConfirmeePar") // Réservations confirmées
  mediaGalerieCrees             MediaGalerie[]               @relation("MediaGalerieCreatedBy") // Médias de galerie créés
  rapportsReunionCrees          RapportReunion[]             @relation("RapportReunionCreatedBy") // Rapports de réunion créés
  rapportsReunionModifies       RapportReunion[]             @relation("RapportReunionUpdatedBy") // Rapports de réunion modifiés
  menusCreated                  Menu[]                       @relation("MenuCreatedBy") // Menus créés
  permissionsCreated            Permission[]                 @relation("PermissionCreatedBy") // Permissions créées
  activities                    UserActivity[]               @relation("UserActivities") // Activités de l'utilisateur
  projetsCrees                  Projet[]                     @relation("ProjetCreatedBy") // Projets créés

  lastLogin DateTime? @updatedAt
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  remember_token        String?                @db.VarChar(100)
  isTwoFactorEnabled    Boolean                @default(false)
  twoFactorConfirmation TwoFactorConfirmation?

  @@map("users")
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("verification_tokens")
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("password_reset_tokens")
}

model TwoFactorToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("two_factor_tokens")
}

model TwoFactorConfirmation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@map("two_factor_confirmations")
}

model Adherent {
  id                            String                       @id @default(cuid())
  civility                      Civilities?                  @default(Monsieur)
  firstname                     String                       @db.VarChar(255)
  lastname                      String                       @db.VarChar(255)
  dateNaissance                 DateTime? // Date de naissance
  typeAdhesion                  TypeAdhesion? // Type d'adhésion
  profession                    String?                      @db.VarChar(255) // Profession (optionnel)
  anneePromotion                String?                      @db.VarChar(10) // Année de promotion à Kipaku (ex: "2010" ou "Non")
  centresInteret                String?                      @db.Text // Centres d'intérêt
  autorisationImage             Boolean                      @default(false) // Autorisation d'utilisation de l'image
  accepteCommunications         Boolean                      @default(true) // Acceptation des communications
  nombreEnfants                 Int                          @default(0) // Nombre d'enfants
  evenementsFamiliaux           String?                      @db.Text // JSON array des types d'événements familiaux
  // Champs pour la gestion des frais d'adhésion
  datePremiereAdhesion          DateTime? // Date de première adhésion à l'association
  fraisAdhesionPaye             Boolean                      @default(false) // Indique si les frais d'adhésion ont été payés
  datePaiementFraisAdhesion     DateTime? // Date de paiement des frais d'adhésion
  estAncienAdherent             Boolean                      @default(false) // Flag pour marquer les anciens adhérents
  // Champs pour le passeport adhérent
  numeroPasseport               String?                      @db.VarChar(50) // Numéro unique du passeport AMAKI
  dateGenerationPasseport       DateTime? // Date de génération du passeport
  // Poste de l'adhérent dans l'association
  posteTemplateId               String? // Poste de l'adhérent (par défaut: Membre de l'association)
  PosteTemplate                 PosteTemplate?               @relation(fields: [posteTemplateId], references: [id], onDelete: SetNull)
  Adresse                       Adresse[]
  Cotisations                   Cotisation[]
  Telephones                    Telephone[]
  ObligationsCotisation         ObligationCotisation[]
  Relances                      Relance[]
  Candidacies                   Candidacy[]
  Votes                         Vote[]
  CotisationsMensuelles         CotisationMensuelle[] // Cotisations mensuelles (payeur)
  CotisationsMensuellesBeneficiaire CotisationMensuelle[]    @relation("CotisationMensuelleBeneficiaire") // Cotisations mensuelles dont l'adhérent est bénéficiaire (assistances)
  RelancesCotisationMensuelle   RelanceCotisationMensuelle[] // Relances cotisations mensuelles
  CotisationsDuMoisBeneficiaire CotisationDuMois[]           @relation("CotisationDuMoisBeneficiaire") // Cotisations du mois dont l'adhérent est bénéficiaire (assistances)
  InscriptionsEvenements        InscriptionEvenement[] // Inscriptions aux événements
  idees                         Idee[] // Idées soumises par l'adhérent
  commentairesIdee              CommentaireIdee[] // Commentaires sur les idées
  approbationsIdee              ApprobationIdee[] // Approbations des idées
  Enfants                       Enfant[] // Enfants de l'adhérent
  DettesInitiales               DetteInitiale[] // Dettes initiales
  Paiements                     PaiementCotisation[] // Paiements effectués
  Assistances                   Assistance[] // Assistances reçues
  Avoirs                        Avoir[] // Avoirs (excédents de paiement)
  documents                     Document[]                   @relation("DocumentAdherent") // Documents liés à l'adhérent
  Reservations                  Reservation[] // Réservations effectuées
  affectationsSousProjets       AffectationSousProjet[] // Affectations aux sous-projets/tâches
  commentairesTaches            CommentaireTache[] // Commentaires sur les tâches
  created_at                    DateTime?                    @db.Timestamp(0)
  updated_at                    DateTime?                    @db.Timestamp(0)
  userId                        String                       @unique
  User                          User                         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("adherent")
}

// Configuration pour les frais d'adhésion
model ConfigurationFraisAdhesion {
  id                   String   @id @default(cuid())
  montantFraisAdhesion Decimal  @db.Decimal(10, 2) // Montant des frais d'adhésion
  actif                Boolean  @default(true)
  description          String?  @db.Text
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  createdBy            String
  CreatedBy            User     @relation("ConfigurationFraisAdhesionCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)

  @@map("configuration_frais_adhesion")
}

model Adresse {
  id          String   @id @default(cuid())
  adherentId  String
  streetnum   String?
  street1     String?
  street2     String?
  codepost    String?
  city        String?
  country     String?
  // Champs pour l'API BAN (Base Adresse Nationale)
  banId       String?  @db.VarChar(100) // ID de l'adresse dans l'API BAN
  label       String?  @db.VarChar(500) // Adresse complète formatée (ex: "10 Rue de la Paix, 75001 Paris")
  housenumber String?  @db.VarChar(20) // Numéro de maison
  street      String?  @db.VarChar(200) // Nom de la rue
  postcode    String?  @db.VarChar(10) // Code postal (normalisé)
  citycode    String?  @db.VarChar(10) // Code INSEE de la commune
  department  String?  @db.VarChar(10) // Code département
  region      String?  @db.VarChar(100) // Nom de la région
  latitude    Float? // Coordonnée GPS latitude
  longitude   Float? // Coordonnée GPS longitude
  score       Float? // Score de pertinence (0-1)
  type        String?  @db.VarChar(50) // Type d'adresse (housenumber, street, municipality, etc.)
  metadata    Json? // Métadonnées supplémentaires de l'API BAN
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  @@index([banId])
  @@index([postcode])
  @@index([citycode])
  @@index([department])
  @@map("adresse")
}

// Table pour stocker les adresses normalisées de l'API BAN (cache)
model BanAddress {
  id          String   @id @default(cuid())
  banId       String   @unique @db.VarChar(100) // ID unique de l'API BAN
  label       String   @db.VarChar(500) // Adresse complète formatée
  housenumber String?  @db.VarChar(20)
  street      String?  @db.VarChar(200)
  postcode    String   @db.VarChar(10)
  city        String   @db.VarChar(200)
  citycode    String   @db.VarChar(10) // Code INSEE
  department  String?  @db.VarChar(10)
  region      String?  @db.VarChar(100)
  latitude    Float
  longitude   Float
  score       Float? // Score de pertinence
  type        String   @db.VarChar(50) // housenumber, street, municipality, etc.
  metadata    Json? // Métadonnées complètes de l'API BAN
  searchText  String?  @db.Text // Texte de recherche pour indexation
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([postcode])
  @@index([citycode])
  @@index([department])
  @@index([city])
  @@index([street])
  @@index([searchText])
  @@map("ban_address")
}

model Cotisation {
  id             String         @id @default(cuid())
  adherentId     String
  type           TypeCotisation
  montant        Decimal        @db.Decimal(10, 2)
  dateCotisation DateTime       @default(now())
  moyenPaiement  MoyenPaiement
  description    String?        @db.Text
  reference      String?        @db.VarChar(100)
  statut         String         @default("Valide") // Valide, Annule, EnAttente
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  @@map("cotisations")
}

model Telephone {
  id           String        @id @default(cuid())
  adherentId   String
  numero       String        @db.VarChar(20)
  type         TypeTelephone
  estPrincipal Boolean       @default(false)
  description  String?       @db.VarChar(255)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  @@map("telephones")
}

// Modèle pour les enfants des adhérents
model Enfant {
  id            String    @id @default(cuid())
  adherentId    String
  prenom        String    @db.VarChar(255)
  dateNaissance DateTime? // Date de naissance
  age           Int? // Âge (calculé ou saisi)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  @@map("enfants")
}

model ObligationCotisation {
  id             String         @id @default(cuid())
  adherentId     String
  type           TypeCotisation
  montantAttendu Decimal        @db.Decimal(10, 2)
  montantPaye    Decimal        @default(0) @db.Decimal(10, 2)
  montantRestant Decimal        @db.Decimal(10, 2)
  dateEcheance   DateTime
  periode        String         @db.VarChar(50) // ex: "2024-01", "2024-Anniversaire"
  statut         String         @default("EnAttente") // EnAttente, PartiellementPaye, Paye, EnRetard
  description    String?        @db.Text
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  Adherent          Adherent             @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  Relances          Relance[]
  Paiements         PaiementCotisation[] // Paiements liés à cette obligation
  UtilisationsAvoir UtilisationAvoir[] // Utilisations d'avoirs pour cette obligation

  @@map("obligations_cotisation")
}

model Relance {
  id                     String        @id @default(cuid())
  adherentId             String
  obligationCotisationId String
  type                   TypeRelance
  statut                 StatutRelance @default(EnAttente)
  dateEnvoi              DateTime?
  dateRelance            DateTime?
  contenu                String?       @db.Text
  reponse                String?       @db.Text
  montantRappele         Decimal?      @db.Decimal(10, 2)
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt

  Adherent             Adherent             @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  ObligationCotisation ObligationCotisation @relation(fields: [obligationCotisationId], references: [id], onDelete: Cascade)

  @@map("relances")
}

// Modèles pour le système d'élections
model Election {
  id          String         @id @default(cuid())
  titre       String         @db.VarChar(255)
  description String?        @db.Text
  status      ElectionStatus @default(Preparation)

  // Dates importantes
  dateOuverture          DateTime
  dateCloture            DateTime
  dateClotureCandidature DateTime // Date limite pour postuler (obligatoire: dateOuverture < dateClotureCandidature < dateScrutin < dateCloture)
  dateScrutin            DateTime

  // Configuration
  nombreMandats  Int     @default(1) // Nombre de postes à pourvoir
  quorumRequis   Int? // Quorum requis pour valider l'élection
  majoriteRequis String? @db.VarChar(50) // "Absolue", "Relative", "Qualifiée"

  // Relations
  positions   Position[]
  candidacies Candidacy[]
  votes       Vote[]

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String // ID de l'utilisateur qui a créé l'élection

  @@map("elections")
}

model Position {
  id          String       @id @default(cuid())
  electionId  String
  type        PositionType // Conservé pour rétrocompatibilité
  titre       String       @db.VarChar(255)
  description String?      @db.Text

  // Nouvelle référence au template de poste
  posteTemplateId String? // Optionnel pour migration progressive
  PosteTemplate   PosteTemplate? @relation(fields: [posteTemplateId], references: [id], onDelete: SetNull)

  // Configuration spécifique au poste
  nombreMandats Int     @default(1)
  dureeMandat   Int? // Durée en mois
  conditions    String? @db.Text // Conditions spécifiques

  // Relations
  election    Election    @relation(fields: [electionId], references: [id], onDelete: Cascade)
  candidacies Candidacy[]
  votes       Vote[]

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([electionId, type])
  @@index([posteTemplateId])
  @@map("positions")
}

model Candidacy {
  id         String @id @default(cuid())
  electionId String
  positionId String
  adherentId String

  // Informations de candidature
  status     CandidacyStatus @default(EnAttente)
  motivation String?         @db.Text
  programme  String?         @db.Text

  // Documents joints
  documents String? @db.Text // JSON array des URLs des documents

  // Validation
  valideePar     String? // ID de l'utilisateur qui a validé
  dateValidation DateTime?
  commentaires   String?   @db.Text

  // Relations
  election Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  position Position @relation(fields: [positionId], references: [id], onDelete: Cascade)
  adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  votes    Vote[]

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([electionId, positionId, adherentId])
  @@map("candidacies")
}

model Vote {
  id         String @id @default(cuid())
  electionId String
  positionId String
  adherentId String // Adhérent qui vote

  // Candidat choisi (peut être null pour vote blanc)
  candidacyId String?

  // Informations du vote
  status    VoteStatus @default(Valide)
  dateVote  DateTime   @default(now())
  ipAddress String?    @db.VarChar(45) // Pour audit
  userAgent String?    @db.VarChar(500) // Pour audit

  // Relations
  election  Election   @relation(fields: [electionId], references: [id], onDelete: Cascade)
  position  Position   @relation(fields: [positionId], references: [id], onDelete: Cascade)
  adherent  Adherent   @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  candidacy Candidacy? @relation(fields: [candidacyId], references: [id], onDelete: SetNull)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([electionId, positionId, adherentId])
  @@map("votes")
}

model TypeDepense {
  id          String   @id @default(cuid())
  titre       String   @db.VarChar(200)
  description String?  @db.Text
  actif       Boolean  @default(true)
  createdBy   String // ID de l'admin qui a créé le type
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  CreatedBy User      @relation("TypeDepenseCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  Depenses  Depense[] // Dépenses de ce type

  @@map("types_depense")
}

model Depense {
  id            String   @id @default(cuid())
  libelle       String   @db.VarChar(200)
  montant       Decimal  @db.Decimal(10, 2)
  dateDepense   DateTime
  typeDepenseId String? // Référence au type de dépense (remplace categorie)
  categorie     String?  @db.VarChar(100) // Conservé pour compatibilité, sera remplacé par typeDepenseId
  description   String?  @db.Text
  justificatif  String?  @db.VarChar(500) // URL du fichier uploadé (conservé pour compatibilité)
  statut        String   @default("EnAttente") // EnAttente, Valide, Rejete
  createdBy     String // ID de l'admin qui a créé la dépense
  validatedBy   String? // ID de l'admin qui a validé la dépense (null si non validée)

  // Relations
  CreatedBy     User                  @relation("DepenseCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  ValidatedBy   User?                 @relation("DepenseValidatedBy", fields: [validatedBy], references: [id], onDelete: SetNull)
  TypeDepense   TypeDepense?          @relation(fields: [typeDepenseId], references: [id], onDelete: SetNull)
  Justificatifs JustificatifDepense[] // Justificatifs de la dépense

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("depenses")
}

model JustificatifDepense {
  id         String @id @default(cuid())
  depenseId  String // Référence à la dépense
  nomFichier String @db.VarChar(255) // Nom original du fichier
  chemin     String @db.VarChar(500) // Chemin relatif dans /public/ressources/justificatifs
  typeMime   String @db.VarChar(100) // Type MIME (application/pdf, image/jpeg, etc.)
  taille     Int // Taille en octets
  uploadedBy String // ID de l'admin qui a uploadé le fichier

  // Relations
  Depense    Depense @relation(fields: [depenseId], references: [id], onDelete: Cascade)
  UploadedBy User    @relation("JustificatifUploadedBy", fields: [uploadedBy], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("justificatifs_depense")
}

model TypeCotisationMensuelle {
  id            String  @id @default(cuid())
  nom           String  @db.VarChar(100) // ex: "Forfait Mensuel", "Décès", "Formation", etc.
  description   String? @db.Text
  montant       Decimal @db.Decimal(10, 2)
  obligatoire   Boolean @default(true) // Si la cotisation est obligatoire
  actif         Boolean @default(true) // Si le type est actuellement utilisé
  ordre         Int     @default(0) // Ordre d'affichage
  /// Catégorie : ForfaitMensuel (obligatoire), Assistance (bénéficiaire), Divers (extra)
  categorie     CategorieTypeCotisation @default(Divers)
  aBeneficiaire Boolean @default(false) // Si ce type nécessite un adhérent bénéficiaire (pour les assistances)
  createdBy     String // ID de l'admin qui a créé le type

  // Relations
  CreatedBy             User                   @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  CotisationsMensuelles CotisationMensuelle[]   // Les cotisations créées avec ce type
  CotisationsDuMois     CotisationDuMois[]     // Les cotisations du mois avec ce type
  PassAssistance        PassAssistance?        // Config montant fixe (une par type de cotisation Assistance)
  Assistances           Assistance[]           // Assistances liées à ce type (pour montant)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("types_cotisation_mensuelle")
}

// Table pour gérer les cotisations du mois (planification par l'admin)
// Permet à l'admin de créer, modifier, rechercher et trier les cotisations par mois/année
// Pour les assistances, contient l'adhérent bénéficiaire qui ne paiera pas cette cotisation
model CotisationDuMois {
  id                     String   @id @default(cuid())
  periode                String   @db.VarChar(50) // ex: "2024-01", "2024-02"
  annee                  Int
  mois                   Int
  typeCotisationId       String // Référence au type de cotisation
  montantBase            Decimal  @db.Decimal(10, 2) // Montant de base pour ce type de cotisation ce mois
  dateEcheance           DateTime // Date d'échéance pour cette cotisation
  description            String?  @db.Text
  statut                 String   @default("Planifie") // Planifie, Cree, Annule
  adherentBeneficiaireId String? // Pour les assistances : l'adhérent bénéficiaire qui ne paiera pas
  createdBy              String // ID de l'admin qui a créé la cotisation du mois

  // Relations
  TypeCotisation        TypeCotisationMensuelle @relation(fields: [typeCotisationId], references: [id], onDelete: Cascade)
  CreatedBy             User                    @relation("CotisationDuMoisCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  AdherentBeneficiaire  Adherent?               @relation("CotisationDuMoisBeneficiaire", fields: [adherentBeneficiaireId], references: [id], onDelete: SetNull)
  CotisationsMensuelles CotisationMensuelle[] // Les cotisations créées à partir de cette planification

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Contrainte : un adhérent ne peut avoir qu'une seule assistance par mois
  // (peu importe le type d'assistance : mariage, anniversaire, etc.)
  // Cette contrainte s'applique uniquement quand adherentBeneficiaireId n'est pas null
  // PostgreSQL permet plusieurs NULL dans une contrainte unique, donc les types sans bénéficiaire ne sont pas affectés
  @@unique([periode, adherentBeneficiaireId], name: "unique_adherent_assistance_periode")
  @@index([annee])
  @@index([mois])
  @@index([statut])
  @@index([adherentBeneficiaireId])
  @@index([periode, typeCotisationId])
  @@map("cotisations_du_mois")
}

model CotisationMensuelle {
  id                     String   @id @default(cuid())
  periode                String   @db.VarChar(50) // ex: "2024-01", "2024-02"
  annee                  Int
  mois                   Int
  typeCotisationId       String // Référence au type de cotisation
  adherentId             String // Adhérent concerné (payeur)
  adherentBeneficiaireId String? // Pour les assistances : id de l'adhérent bénéficiaire
  montantAttendu         Decimal  @db.Decimal(10, 2)
  montantPaye            Decimal  @default(0) @db.Decimal(10, 2)
  montantRestant         Decimal  @db.Decimal(10, 2)
  dateEcheance           DateTime
  statut                 String   @default("EnAttente") // EnAttente, PartiellementPaye, Paye, EnRetard
  description            String?  @db.Text
  cotisationDuMoisId     String? // Référence à la cotisation du mois (planification)
  createdBy              String // ID de l'admin qui a créé la cotisation

  // Relations
  TypeCotisation        TypeCotisationMensuelle      @relation(fields: [typeCotisationId], references: [id], onDelete: Cascade)
  Adherent              Adherent                     @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  AdherentBeneficiaire  Adherent?                    @relation("CotisationMensuelleBeneficiaire", fields: [adherentBeneficiaireId], references: [id], onDelete: SetNull)
  CreatedBy             User                         @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  CotisationDuMois      CotisationDuMois?            @relation(fields: [cotisationDuMoisId], references: [id], onDelete: SetNull)
  Relances          RelanceCotisationMensuelle[]
  Paiements         PaiementCotisation[] // Paiements liés à cette cotisation mensuelle
  UtilisationsAvoir UtilisationAvoir[] // Utilisations d'avoirs pour cette cotisation

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Un adhérent peut avoir plusieurs lignes par période (une par cotisation_du_mois : forfait + chaque assistance)
  @@unique([periode, adherentId, cotisationDuMoisId], name: "unique_periode_adherent_cotisation_du_mois")
  @@map("cotisations_mensuelles")
}

model RelanceCotisationMensuelle {
  id                    String    @id @default(cuid())
  cotisationMensuelleId String
  adherentId            String
  type                  String    @default("Email") // Email, SMS, Courrier
  statut                String    @default("EnAttente") // EnAttente, Envoye, Lu, Repondu
  dateEnvoi             DateTime?
  dateRelance           DateTime?
  contenu               String?   @db.Text
  reponse               String?   @db.Text
  montantRappele        Decimal?  @db.Decimal(10, 2)
  createdBy             String // ID de l'admin qui a créé la relance

  // Relations
  CotisationMensuelle CotisationMensuelle @relation(fields: [cotisationMensuelleId], references: [id], onDelete: Cascade)
  Adherent            Adherent            @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  CreatedBy           User                @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("relances_cotisation_mensuelle")
}

// Modèle pour les dettes initiales (2024, 2025, etc.)
model DetteInitiale {
  id             String   @id @default(cuid())
  adherentId     String
  annee          Int // Année de la dette (2024, 2025, etc.)
  montant        Decimal  @db.Decimal(10, 2) // Montant total de la dette pour l'année
  montantPaye    Decimal  @default(0) @db.Decimal(10, 2) // Montant déjà payé
  montantRestant Decimal  @db.Decimal(10, 2) // Montant restant à payer
  description    String?  @db.Text
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdBy      String // ID de l'admin qui a créé la dette

  // Relations
  Adherent          Adherent             @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  CreatedBy         User                 @relation("DetteInitialeCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  Paiements         PaiementCotisation[] // Paiements liés à cette dette
  UtilisationsAvoir UtilisationAvoir[] // Utilisations d'avoirs pour cette dette

  @@unique([adherentId, annee])
  @@map("dettes_initiales")
}

// Modèle pour les paiements de cotisations (partiels ou complets)
model PaiementCotisation {
  id            String        @id @default(cuid())
  adherentId    String
  montant       Decimal       @db.Decimal(10, 2)
  datePaiement  DateTime      @default(now())
  moyenPaiement MoyenPaiement
  reference     String?       @db.VarChar(100) // Référence du paiement (chèque, virement, etc.)
  description   String?       @db.Text

  // Liens vers les obligations/cotisations payées
  obligationCotisationId String? // Si le paiement concerne une obligation
  cotisationMensuelleId  String? // Si le paiement concerne une cotisation mensuelle
  detteInitialeId        String? // Si le paiement concerne une dette initiale
  assistanceId           String? // Si le paiement concerne une assistance

  // Informations pour les paiements en ligne
  stripePaymentIntentId String? @unique @db.VarChar(255) // ID du PaymentIntent Stripe
  stripeSessionId       String? @unique @db.VarChar(255) // ID de la session Stripe Checkout
  paypalOrderId         String? @unique @db.VarChar(255) // ID de la commande PayPal
  transactionId         String? @unique @db.VarChar(255) // ID de transaction unique (pour tous les prestataires)
  receiptUrl            String? @db.VarChar(500) // URL du reçu PDF généré
  receiptGenerated      Boolean @default(false) // Si le reçu a été généré
  justificatifChemin    String? @db.VarChar(500) // Preuve du virement (obligatoire si moyenPaiement = Virement)

  statut    String @default("Valide") // Valide, Annule, EnAttente, EnCours (pour paiements en ligne)
  createdBy String // ID de l'admin qui a enregistré le paiement (ou "system" pour paiements en ligne)

  // Relations
  Adherent             Adherent              @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  ObligationCotisation ObligationCotisation? @relation(fields: [obligationCotisationId], references: [id], onDelete: SetNull)
  CotisationMensuelle  CotisationMensuelle?  @relation(fields: [cotisationMensuelleId], references: [id], onDelete: SetNull)
  DetteInitiale        DetteInitiale?        @relation(fields: [detteInitialeId], references: [id], onDelete: SetNull)
  Assistance           Assistance?           @relation(fields: [assistanceId], references: [id], onDelete: SetNull)
  CreatedBy            User                  @relation("PaiementCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  Avoir                Avoir?                @relation("AvoirFromPaiement") // Avoir créé par ce paiement (si excédent)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("paiements_cotisation")
}

// Modèle pour les avoirs (excédents de paiement)
model Avoir {
  id             String  @id @default(cuid())
  adherentId     String
  montant        Decimal @db.Decimal(10, 2) // Montant de l'avoir
  montantUtilise Decimal @default(0) @db.Decimal(10, 2) // Montant déjà utilisé
  montantRestant Decimal @db.Decimal(10, 2) // Montant restant disponible

  // Origine de l'avoir
  paiementId  String? @unique // ID du paiement qui a créé cet avoir (si applicable) - unique car un paiement ne peut créer qu'un seul avoir
  description String? @db.Text // Description de l'origine de l'avoir

  // Utilisation de l'avoir
  statut String @default("Disponible") // Disponible, Utilise, Expire

  // Relations
  Adherent     Adherent            @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  Paiement     PaiementCotisation? @relation("AvoirFromPaiement", fields: [paiementId], references: [id], onDelete: SetNull)
  Utilisations UtilisationAvoir[] // Utilisations de cet avoir

  // Métadonnées
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  dateExpiration DateTime? // Date d'expiration de l'avoir (optionnel)

  @@index([adherentId])
  @@index([statut])
  @@map("avoirs")
}

// Modèle pour les utilisations d'avoirs
model UtilisationAvoir {
  id      String  @id @default(cuid())
  avoirId String
  montant Decimal @db.Decimal(10, 2) // Montant utilisé

  // Lien vers ce qui a été payé avec cet avoir
  cotisationMensuelleId  String? // Si utilisé pour une cotisation mensuelle
  obligationCotisationId String? // Si utilisé pour une obligation
  detteInitialeId        String? // Si utilisé pour une dette initiale
  assistanceId           String? // Si utilisé pour une assistance

  description     String?  @db.Text
  dateUtilisation DateTime @default(now())

  // Relations
  Avoir                Avoir                 @relation(fields: [avoirId], references: [id], onDelete: Cascade)
  CotisationMensuelle  CotisationMensuelle?  @relation(fields: [cotisationMensuelleId], references: [id], onDelete: SetNull)
  ObligationCotisation ObligationCotisation? @relation(fields: [obligationCotisationId], references: [id], onDelete: SetNull)
  DetteInitiale        DetteInitiale?        @relation(fields: [detteInitialeId], references: [id], onDelete: SetNull)
  Assistance           Assistance?           @relation(fields: [assistanceId], references: [id], onDelete: SetNull)

  // Métadonnées
  createdAt DateTime @default(now())

  @@index([avoirId])
  @@map("utilisations_avoir")
}

// Modèle pour les assistances (50€ pour naissance, décès, anniversaire, mariage)
model Assistance {
  id               String                 @id @default(cuid())
  adherentId       String
  type             TypeEvenementFamilial  // Naissance, MariageEnfant, DecesFamille, AnniversaireSalle, Autre
  typeCotisationId String?                // Type de cotisation (Assistance) pour récupérer le montant depuis PassAssistance
  montant          Decimal                @default(50.00) @db.Decimal(10, 2) // Montant fixe de 50€
  dateEvenement    DateTime               // Date de l'événement
  montantPaye      Decimal                @default(0) @db.Decimal(10, 2)
  montantRestant   Decimal                @db.Decimal(10, 2)
  statut           String                 @default("EnAttente") // EnAttente, Affecte, Paye, Annule
  description      String?                @db.Text
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  createdBy        String                 // ID de l'admin qui a créé l'assistance

  // Relations
  Adherent            Adherent              @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  TypeCotisation      TypeCotisationMensuelle? @relation(fields: [typeCotisationId], references: [id], onDelete: SetNull)
  CreatedBy           User                  @relation("AssistanceCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  Paiements           PaiementCotisation[]  // Paiements liés à cette assistance
  UtilisationsAvoir   UtilisationAvoir[]   // Utilisations d'avoirs pour cette assistance

  @@map("assistances")
}

/// Table de configuration du montant fixe par type d'assistance (créée à la demande, liée à un type de cotisation catégorie Assistance)
model PassAssistance {
  id                  String   @id @default(cuid())
  description         String   @db.VarChar(500)
  montant             Decimal  @db.Decimal(10, 2)
  typeCotisationId    String   // Relation obligatoire avec TypeCotisationMensuelle (catégorie Assistance)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  TypeCotisationMensuelle TypeCotisationMensuelle @relation(fields: [typeCotisationId], references: [id], onDelete: Restrict)

  @@unique([typeCotisationId], name: "pass_assistance_type_unique")
  @@map("pass_assistance")
}

// Modèle pour la gestion des événements
model Evenement {
  id                    String    @id @default(cuid())
  titre                 String    @db.VarChar(200)
  description           String    @db.Text
  contenu               String?   @db.Text // Contenu détaillé de l'événement
  dateDebut             DateTime
  dateFin               DateTime?
  dateAffichage         DateTime // Date à partir de laquelle l'événement est visible
  dateFinAffichage      DateTime // Date jusqu'à laquelle l'événement reste visible
  lieu                  String?   @db.VarChar(200)
  adresse               String?   @db.Text
  categorie             String    @default("General") @db.VarChar(50) // General, Formation, Social, Sportif, Culturel
  statut                String    @default("Brouillon") // Brouillon, Publie, Archive
  estPublic             Boolean   @default(true) // Si true : visible par tout le monde sur /evenements, si false : réservé aux adhérents sur /agenda
  imagePrincipale       String?   @db.VarChar(500) // URL de l'image principale
  images                String?   @db.Text // JSON array des URLs d'images supplémentaires
  prix                  Decimal?  @db.Decimal(10, 2) // Prix de participation (optionnel)
  placesDisponibles     Int? // Nombre de places disponibles
  placesReservees       Int       @default(0) // Nombre de places réservées
  inscriptionRequis     Boolean   @default(false) // Si une inscription est requise
  dateLimiteInscription DateTime? // Date limite pour s'inscrire
  contactEmail          String?   @db.VarChar(100)
  contactTelephone      String?   @db.VarChar(20)
  tags                  String?   @db.Text // JSON array des tags
  createdBy             String // ID de l'admin qui a créé l'événement

  // Relations
  CreatedBy     User                   @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Inscriptions  InscriptionEvenement[] // Inscriptions à cet événement
  Conversations Conversation[] // Conversations liées à cet événement

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("evenements")
}

// Modèle pour les inscriptions aux événements
model InscriptionEvenement {
  id              String   @id @default(cuid())
  evenementId     String
  adherentId      String? // Optionnel pour permettre les inscriptions de visiteurs
  statut          String   @default("EnAttente") // EnAttente, Confirmee, Annulee
  dateInscription DateTime @default(now())
  commentaires    String?  @db.Text
  nombrePersonnes Int      @default(1) // Nombre de personnes inscrites

  // Informations du visiteur (pour les non-adhérents)
  visiteurNom       String? @db.VarChar(255)
  visiteurEmail     String? @db.VarChar(255)
  visiteurTelephone String? @db.VarChar(20)
  visiteurAdresse   String? @db.Text

  // Relations
  Evenement Evenement @relation(fields: [evenementId], references: [id], onDelete: Cascade)
  Adherent  Adherent? @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([evenementId, adherentId])
  @@index([evenementId, visiteurEmail])
  @@map("inscriptions_evenements")
}

// Modèle pour le système de chat
model Conversation {
  id          String  @id @default(cuid())
  titre       String? @db.VarChar(200) // Titre optionnel pour les conversations de groupe
  type        String  @default("Privee") // Privee, Groupe, Evenement
  evenementId String? // Pour les conversations liées à un événement
  createdBy   String // ID de l'utilisateur qui a créé la conversation

  // Relations
  CreatedBy    User                      @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Evenement    Evenement?                @relation(fields: [evenementId], references: [id], onDelete: Cascade)
  Participants ConversationParticipant[] // Participants à la conversation
  Messages     Message[] // Messages de la conversation

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("conversations")
}

// Modèle pour les participants d'une conversation
model ConversationParticipant {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  role           String    @default("Participant") // Participant, Admin, Modérateur
  joinedAt       DateTime  @default(now())
  leftAt         DateTime? // Si null, le participant est toujours dans la conversation

  // Relations
  Conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  User         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

// Modèle pour les messages du chat
model Message {
  id             String    @id @default(cuid())
  conversationId String
  userId         String // ID de l'utilisateur qui a envoyé le message
  content        String    @db.Text // Contenu du message
  type           String    @default("Texte") // Texte, Image, Fichier, System
  fileUrl        String?   @db.VarChar(500) // URL du fichier si type = Image ou Fichier
  fileName       String?   @db.VarChar(255) // Nom du fichier original
  replyToId      String? // ID du message auquel on répond (pour les réponses)
  edited         Boolean   @default(false) // Si le message a été modifié
  editedAt       DateTime? // Date de modification
  deleted        Boolean   @default(false) // Si le message a été supprimé
  deletedAt      DateTime? // Date de suppression

  // Relations
  Conversation Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  User         User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  ReplyTo      Message?          @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  Replies      Message[]         @relation("MessageReplies")
  Reactions    MessageReaction[] // Réactions aux messages

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([conversationId, createdAt])
  @@index([userId])
  @@map("messages")
}

// Modèle pour les réactions aux messages (emojis, likes, etc.)
model MessageReaction {
  id        String @id @default(cuid())
  messageId String
  userId    String
  reaction  String @db.VarChar(10) // Emoji ou type de réaction (👍, ❤️, etc.)

  // Relations
  Message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  User    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())

  @@unique([messageId, userId, reaction])
  @@map("message_reactions")
}

// Enum pour le statut d'une idée
enum StatutIdee {
  EnAttente
  Validee
  Rejetee
  Bloquee
  DevenueProjet
}

enum StatutDemandeSuppression {
  EnAttente // Demande reçue, en attente de vérification
  EnVerification // Vérification d'identité en cours
  Approuvee // Demande approuvée, suppression programmée
  Rejetee // Demande rejetée (identité non vérifiée, etc.)
  Completee // Suppression effectuée
  Annulee // Demande annulée par l'utilisateur ou l'admin
}

enum TypeNotification {
  Systeme
  Email
  Action
  Cotisation
  Idee
  Election
  Evenement
  Chat
  Autre
}

enum TypeDocument {
  PDF
  Image
  Video
  Excel
  Word
  Autre
}

// Modèle pour les idées de la boîte à idées
model Idee {
  id                 String     @id @default(cuid())
  titre              String     @db.VarChar(255)
  description        String     @db.Text
  adherentId         String // Auteur de l'idée
  statut             StatutIdee @default(EnAttente)
  nombreCommentaires Int        @default(0) // Compteur de commentaires
  nombreApprobations Int        @default(0) // Compteur d'approbations

  // Dates importantes
  dateCreation   DateTime  @default(now())
  dateValidation DateTime? // Date de validation par l'admin
  dateRejet      DateTime? // Date de rejet par l'admin
  dateBlocage    DateTime? // Date de blocage par l'admin

  // Raison du rejet ou du blocage
  raisonRejet String? @db.Text // Raison du rejet (viole l'éthique, propos diffamatoires, etc.)

  // Admin qui a validé/rejeté/bloqué
  valideePar String? // ID de l'admin qui a validé
  rejeteePar String? // ID de l'admin qui a rejeté
  bloqueePar String? // ID de l'admin qui a bloqué

  // Si l'idée est déjà lue (pour empêcher la suppression directe)
  estLue Boolean @default(false) // Si au moins un commentaire ou approbation existe

  // Relations
  Adherent     Adherent          @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  Commentaires CommentaireIdee[] // Commentaires sur cette idée
  Approbations ApprobationIdee[] // Approbations de cette idée

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([adherentId])
  @@index([statut])
  @@index([dateCreation])
  @@map("idees")
}

// Enum pour le type de badge
enum BadgeType {
  Automatique
  Manuel
}

// Modèle pour les badges
model Badge {
  id           String             @id @default(cuid())
  nom          String             @db.VarChar(255)
  description  String             @db.Text
  icone        String             @db.VarChar(100) // Nom de l'icône lucide-react
  couleur      String             @db.VarChar(50) // Couleur du badge (ex: "blue", "green", "gold")
  type         BadgeType          @default(Manuel)
  condition    String?            @db.Text // Condition JSON pour badges automatiques
  actif        Boolean            @default(true)
  ordre        Int                @default(0) // Ordre d'affichage
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  Attributions BadgeAttribution[]

  @@index([type])
  @@index([actif])
  @@map("badges")
}

// Modèle pour les attributions de badges aux utilisateurs
model BadgeAttribution {
  id          String   @id @default(cuid())
  badgeId     String
  userId      String
  attribuePar String? // ID de l'admin qui a attribué (si manuel)
  raison      String?  @db.Text // Raison de l'attribution
  createdAt   DateTime @default(now())

  // Relations
  Badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  User  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([badgeId, userId])
  @@index([userId])
  @@index([badgeId])
  @@index([createdAt])
  @@map("badge_attributions")
}

// Modèle pour les commentaires sur les idées
model CommentaireIdee {
  id                String  @id @default(cuid())
  ideeId            String
  adherentId        String // Auteur du commentaire
  contenu           String  @db.Text
  supprime          Boolean @default(false) // Si le commentaire a été supprimé par l'admin
  raisonSuppression String? @db.Text // Raison de la suppression

  // Relations
  Idee     Idee     @relation(fields: [ideeId], references: [id], onDelete: Cascade)
  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ideeId])
  @@index([adherentId])
  @@map("commentaires_idee")
}

// Modèle pour les approbations (votes/likes) des idées
model ApprobationIdee {
  id         String @id @default(cuid())
  ideeId     String
  adherentId String // Adhérent qui approuve

  // Relations
  Idee     Idee     @relation(fields: [ideeId], references: [id], onDelete: Cascade)
  Adherent Adherent @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())

  @@unique([ideeId, adherentId])
  @@index([ideeId])
  @@index([adherentId])
  @@map("approbations_idee")
}

// Modèle pour les notifications utilisateur
model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      TypeNotification @default(Systeme)
  titre     String           @db.VarChar(255)
  message   String           @db.Text
  lien      String?          @db.VarChar(500) // URL optionnelle pour redirection
  lue       Boolean          @default(false)
  createdAt DateTime         @default(now())
  User      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lue])
  @@index([createdAt])
  @@map("notifications")
}

// Modèle pour l'historique des emails envoyés aux adhérents
model Email {
  id             String   @id @default(cuid())
  userId         String // Destinataire de l'email
  createdBy      String // Admin qui a envoyé l'email
  subject        String   @db.VarChar(255)
  body           String   @db.Text
  recipientEmail String   @db.VarChar(255) // Email du destinataire au moment de l'envoi
  sent           Boolean  @default(true) // Si l'email a été envoyé avec succès
  error          String?  @db.Text // Message d'erreur si l'envoi a échoué
  createdAt      DateTime @default(now())

  // Relations
  User      User @relation("EmailRecipient", fields: [userId], references: [id], onDelete: Cascade)
  CreatedBy User @relation("EmailCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdBy])
  @@index([createdAt])
  @@index([sent])
  @@map("emails")
}

// Modèle pour l'historique des suppressions d'adhérents
model SuppressionAdherent {
  id                String   @id @default(cuid())
  userId            String // ID de l'utilisateur supprimé (conservé pour référence)
  userName          String   @db.VarChar(255) // Nom de l'utilisateur au moment de la suppression
  userEmail         String?  @db.VarChar(255) // Email de l'utilisateur au moment de la suppression
  userRole          UserRole // Rôle de l'utilisateur au moment de la suppression
  adherentFirstName String?  @db.VarChar(100) // Prénom de l'adhérent si existait
  adherentLastName  String?  @db.VarChar(100) // Nom de l'adhérent si existait
  reason            String   @db.Text // Raison de la suppression
  notifyUser        Boolean  @default(false) // Si un email de notification a été envoyé
  deletedBy         String // ID de l'admin qui a effectué la suppression
  deletedByName     String   @db.VarChar(255) // Nom de l'admin au moment de la suppression
  deletedByEmail    String?  @db.VarChar(255) // Email de l'admin au moment de la suppression
  createdAt         DateTime @default(now())

  // Relations
  DeletedBy User @relation("SuppressionDeletedBy", fields: [deletedBy], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([deletedBy])
  @@index([createdAt])
  @@index([userEmail])
  @@map("suppressions_adherent")
}

// Modèle pour les demandes de suppression de données (RGPD)
model DataDeletionRequest {
  id              String                   @id @default(cuid())
  userId          String // ID de l'utilisateur qui fait la demande
  userEmail       String                   @db.VarChar(255) // Email de l'utilisateur
  userName        String?                  @db.VarChar(255) // Nom de l'utilisateur au moment de la demande
  message         String?                  @db.Text // Message optionnel de l'utilisateur
  statut          StatutDemandeSuppression @default(EnAttente)
  verifiedAt      DateTime? // Date de vérification d'identité
  verifiedBy      String? // ID de l'admin qui a vérifié
  verifiedByName  String?                  @db.VarChar(255) // Nom de l'admin qui a vérifié
  approvedAt      DateTime? // Date d'approbation
  approvedBy      String? // ID de l'admin qui a approuvé
  approvedByName  String?                  @db.VarChar(255) // Nom de l'admin qui a approuvé
  rejectedAt      DateTime? // Date de rejet
  rejectedBy      String? // ID de l'admin qui a rejeté
  rejectedByName  String?                  @db.VarChar(255) // Nom de l'admin qui a rejeté
  rejectionReason String?                  @db.Text // Raison du rejet
  completedAt     DateTime? // Date de suppression effective
  completedBy     String? // ID de l'admin qui a effectué la suppression
  completedByName String?                  @db.VarChar(255) // Nom de l'admin qui a effectué la suppression
  dataExported    Boolean                  @default(false) // Si les données ont été exportées avant suppression
  exportPath      String?                  @db.VarChar(500) // Chemin du fichier d'export si exporté
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt

  // Relations
  User        User  @relation("DataDeletionRequestUser", fields: [userId], references: [id], onDelete: Cascade)
  VerifiedBy  User? @relation("DataDeletionRequestVerifiedBy", fields: [verifiedBy], references: [id], onDelete: SetNull)
  ApprovedBy  User? @relation("DataDeletionRequestApprovedBy", fields: [approvedBy], references: [id], onDelete: SetNull)
  RejectedBy  User? @relation("DataDeletionRequestRejectedBy", fields: [rejectedBy], references: [id], onDelete: SetNull)
  CompletedBy User? @relation("DataDeletionRequestCompletedBy", fields: [completedBy], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([userEmail])
  @@index([statut])
  @@index([createdAt])
  @@index([verifiedBy])
  @@index([approvedBy])
  @@map("data_deletion_requests")
}

// Modèle pour les documents uploadés
model Document {
  id          String       @id @default(cuid())
  userId      String
  adherentId  String? // Optionnel, pour lier à un adhérent spécifique
  nom         String       @db.VarChar(255) // Nom du fichier stocké
  nomOriginal String       @db.VarChar(255) // Nom original du fichier
  type        TypeDocument
  categorie   String?      @db.VarChar(100) // Catégorie personnalisée
  chemin      String       @db.VarChar(500) // Chemin relatif dans /public/ressources
  taille      Int // Taille en bytes
  mimeType    String       @db.VarChar(100)
  description String?      @db.Text
  estPublic   Boolean      @default(false) // Si visible par les admins
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  User        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  Adherent    Adherent?    @relation("DocumentAdherent", fields: [adherentId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([adherentId])
  @@index([type])
  @@index([createdAt])
  @@map("documents")
}

// Modèle pour les rapports de réunions mensuelles
model RapportReunion {
  id          String   @id @default(cuid())
  titre       String   @db.VarChar(255) // Titre du rapport (ex: "Réunion mensuelle - Janvier 2024")
  dateReunion DateTime // Date de la réunion
  contenu     String   @db.Text // Contenu du rapport (markdown ou texte)
  createdBy   String // Admin qui a créé le rapport
  updatedBy   String? // Admin qui a modifié le rapport
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  CreatedBy User  @relation("RapportReunionCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  UpdatedBy User? @relation("RapportReunionUpdatedBy", fields: [updatedBy], references: [id], onDelete: SetNull)

  @@index([dateReunion])
  @@index([createdAt])
  @@index([createdBy])
  @@map("rapports_reunion")
}

// Modèles pour le système de réservations et gestion de ressources

enum TypeRessource {
  Salle
  Materiel
  Vehicule
  Autre
}

enum StatutReservation {
  EnAttente
  Confirmee
  Annulee
  Terminee
}

model Ressource {
  id           String        @id @default(cuid())
  nom          String        @db.VarChar(255)
  type         TypeRessource
  description  String?       @db.Text
  capacite     Int? // Pour les salles : nombre de places
  localisation String?       @db.VarChar(255) // Adresse ou emplacement
  image        String?       @db.VarChar(500) // URL de l'image

  // Configuration
  actif      Boolean @default(true)
  reservable Boolean @default(true) // Si la ressource peut être réservée

  // Horaires de disponibilité (optionnel)
  horairesOuverture String? @db.Text // JSON : { "lundi": { "debut": "08:00", "fin": "18:00" }, ... }

  // Tarification (optionnel)
  tarifHoraire    Decimal? @db.Decimal(10, 2)
  tarifJournalier Decimal? @db.Decimal(10, 2)

  // Relations
  reservations Reservation[]

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  CreatedBy User     @relation("RessourceCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)

  @@map("ressources")
}

model Reservation {
  id          String  @id @default(cuid())
  ressourceId String
  adherentId  String? // Optionnel pour permettre les réservations de visiteurs

  // Dates et heures
  dateDebut   DateTime
  dateFin     DateTime
  dureeHeures Decimal? @db.Decimal(10, 2) // Durée en heures

  // Statut
  statut StatutReservation @default(EnAttente)

  // Informations de réservation
  motif           String? @db.Text // Raison de la réservation
  nombrePersonnes Int? // Nombre de personnes (pour les salles)
  commentaires    String? @db.Text

  // Informations du visiteur (pour les non-adhérents)
  visiteurNom       String? @db.VarChar(255)
  visiteurEmail     String? @db.VarChar(255)
  visiteurTelephone String? @db.VarChar(20)

  // Confirmation
  confirmeePar     String? // ID de l'admin qui a confirmé
  dateConfirmation DateTime?

  // Relations
  Ressource    Ressource @relation(fields: [ressourceId], references: [id], onDelete: Cascade)
  Adherent     Adherent? @relation(fields: [adherentId], references: [id], onDelete: Cascade)
  ConfirmeePar User?     @relation("ReservationConfirmeePar", fields: [confirmeePar], references: [id], onDelete: SetNull)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ressourceId, dateDebut, dateFin])
  @@index([adherentId])
  @@index([statut])
  @@map("reservations")
}

// Modèle pour la galerie (photos et vidéos)
model MediaGalerie {
  id          String   @id @default(cuid())
  titre       String   @db.VarChar(255)
  description String?  @db.Text
  type        String // "image" ou "video"
  chemin      String   @db.VarChar(500) // Chemin relatif dans /public/ressources/galeries
  nomFichier  String   @db.VarChar(255) // Nom du fichier original
  mimeType    String   @db.VarChar(100)
  taille      Int // Taille en bytes
  categorie   String   @db.VarChar(100) // "Événements Officiels", "Événements Sociaux", "Actions Caritatives", "Formations et Conférences"
  couleur     String   @default("blue") @db.VarChar(50) // "blue", "green", "purple", "orange"
  date        DateTime // Date de l'événement ou de la prise
  lieu        String?  @db.VarChar(200) // Lieu où la photo/vidéo a été prise
  ordre       Int      @default(0) // Ordre d'affichage dans la catégorie
  actif       Boolean  @default(true) // Si le média est visible publiquement
  createdBy   String // ID de l'admin qui a ajouté le média

  // Relations
  CreatedBy User @relation("MediaGalerieCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([categorie])
  @@index([type])
  @@index([actif])
  @@index([ordre])
  @@index([date])
  @@map("media_galerie")
}

// Table pour stocker les villes Geonames
model GeonamesCity {
  id             Int     @id @default(autoincrement())
  geonameId      Int     @unique
  name           String  @db.VarChar(200)
  asciiName      String? @db.VarChar(200)
  alternateNames String? @db.Text
  latitude       Float?
  longitude      Float?
  countryCode    String  @db.VarChar(2)
  admin1Code     String? @db.VarChar(20) // Code région/département
  admin2Code     String? @db.VarChar(80)
  admin3Code     String? @db.VarChar(20)
  admin4Code     String? @db.VarChar(20)
  population     BigInt?
  elevation      Int?
  timezone       String? @db.VarChar(40)
  featureClass   String? @db.VarChar(1)
  featureCode    String? @db.VarChar(10)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([countryCode])
  @@index([name])
  @@index([asciiName])
  @@index([countryCode, name])
  @@map("geonames_city")
}

// Table pour stocker les pays Geonames
model GeonamesCountry {
  id             Int     @id @default(autoincrement())
  geonameId      Int     @unique
  name           String  @db.VarChar(200)
  asciiName      String? @db.VarChar(200)
  alternateNames String? @db.Text
  latitude       Float?
  longitude      Float?
  countryCode    String  @unique @db.VarChar(2) // Code pays ISO 2 lettres (unique)
  cc2            String? @db.VarChar(60) // Codes pays alternatifs
  admin1Code     String? @db.VarChar(20)
  admin2Code     String? @db.VarChar(80)
  admin3Code     String? @db.VarChar(20)
  admin4Code     String? @db.VarChar(20)
  population     BigInt?
  elevation      Int?
  timezone       String? @db.VarChar(40)
  featureClass   String  @db.VarChar(1) // 'A' pour administrative boundaries
  featureCode    String  @db.VarChar(10) // 'PCLI' pour independent political entity

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([countryCode])
  @@index([name])
  @@index([asciiName])
  @@index([featureClass, featureCode])
  @@map("geonames_country")
}

// Table pour stocker les pays depuis Carto ou autres sources
model Country {
  id           Int     @id @default(autoincrement())
  name         String  @db.VarChar(200)
  nameEn       String? @db.VarChar(200) // Nom en anglais
  nameFr       String? @db.VarChar(200) // Nom en français
  code         String  @unique @db.VarChar(2) // Code ISO 2 lettres (unique)
  code3        String? @db.VarChar(3) // Code ISO 3 lettres
  capital      String? @db.VarChar(200) // Capitale
  region       String? @db.VarChar(100) // Région (Europe, Afrique, etc.)
  subregion    String? @db.VarChar(100) // Sous-région
  latitude     Float? // Latitude de la capitale ou du centre
  longitude    Float? // Longitude de la capitale ou du centre
  population   BigInt? // Population
  area         Float? // Superficie en km²
  currency     String? @db.VarChar(10) // Code devise (EUR, USD, etc.)
  currencyName String? @db.VarChar(100) // Nom de la devise
  languages    String? @db.Text // Langues (JSON array)
  timezones    String? @db.Text // Fuseaux horaires (JSON array)
  flag         String? @db.VarChar(500) // URL du drapeau
  source       String  @default("carto") @db.VarChar(50) // Source des données (carto, restcountries, etc.)
  externalId   String? @db.VarChar(100) // ID externe (pour référence)
  metadata     Json? // Métadonnées supplémentaires (JSON)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([name])
  @@index([nameFr])
  @@index([region])
  @@index([source])
  @@map("country")
}

// Table pour stocker les villes depuis Carto ou autres sources
model City {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(200)
  nameEn      String? @db.VarChar(200) // Nom en anglais
  nameFr      String? @db.VarChar(200) // Nom en français
  countryCode String  @db.VarChar(2) // Code pays ISO 2 lettres
  region      String? @db.VarChar(100) // Région/État/Province
  department  String? @db.VarChar(100) // Département (pour la France)
  postalCode  String? @db.VarChar(20) // Code postal
  latitude    Float?
  longitude   Float?
  population  BigInt? // Population
  elevation   Int? // Altitude en mètres
  timezone    String? @db.VarChar(50) // Fuseau horaire
  isCapital   Boolean @default(false) // Si c'est une capitale
  isMajor     Boolean @default(false) // Si c'est une grande ville
  source      String  @default("carto") @db.VarChar(50) // Source des données
  externalId  String? @db.VarChar(100) // ID externe
  metadata    Json? // Métadonnées supplémentaires (JSON)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([countryCode])
  @@index([name])
  @@index([nameFr])
  @@index([countryCode, name])
  @@index([postalCode])
  @@index([region])
  @@index([source])
  @@map("city")
}

// Table pour stocker les configurations de l'application
model AppSettings {
  id          String   @id @default(cuid())
  key         String   @unique @db.VarChar(100) // Clé unique pour identifier le paramètre
  value       String   @db.Text // Valeur du paramètre (peut être JSON)
  description String?  @db.VarChar(500) // Description du paramètre
  category    String   @default("general") @db.VarChar(50) // Catégorie (email, payment, general, etc.)
  updatedBy   String? // ID de l'utilisateur qui a modifié
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([key])
  @@index([category])
  @@map("app_settings")
}

model Menu {
  id          String     @id @default(cuid())
  libelle     String     @db.VarChar(100) // Texte affiché (ex: "Admin", "Élections")
  description String?    @db.VarChar(500) // Description du menu
  lien        String     @db.VarChar(255) // URL du lien (ex: "/admin", "/elections")
  niveau      MenuNiveau // 0=NAVBAR, 1=SIDEBAR
  roles       String[] // Array de rôles (ex: ["ADMIN", "PRESID"])
  icone       String?    @db.VarChar(100) // Nom de l'icône Lucide (ex: "Shield", "Calendar")
  statut      Boolean    @default(true) // true=actif, false=inactif
  ordre       Int        @default(0) // Ordre d'affichage
  parent      String? // ID du menu parent (pour sous-menus)
  electoral   Boolean    @default(false) // Si true, soumis au paramètre electoral_menu_enabled
  createdBy   String? // ID de l'utilisateur qui a créé
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  CreatedBy User? @relation("MenuCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)

  @@index([niveau])
  @@index([statut])
  @@index([ordre])
  @@index([electoral])
  @@map("menus")
}

// Enum pour les types d'activités utilisateurs
enum TypeActivite {
  Connexion
  Deconnexion
  Creation
  Modification
  Suppression
  Consultation
  Export
  Import
  Authentification
  ChangementMotDePasse
  Autre
}

// Table pour tracer les activités des utilisateurs
model UserActivity {
  id           String       @id @default(cuid())
  userId       String // ID de l'utilisateur qui a effectué l'action
  userName     String?      @db.VarChar(255) // Nom de l'utilisateur au moment de l'action
  userEmail    String?      @db.VarChar(255) // Email de l'utilisateur au moment de l'action
  type         TypeActivite // Type d'activité
  action       String       @db.VarChar(255) // Description de l'action (ex: "Création d'un événement")
  entityType   String?      @db.VarChar(100) // Type d'entité concernée (ex: "Evenement", "User", "Cotisation")
  entityId     String?      @db.VarChar(255) // ID de l'entité concernée
  details      Json? // Détails supplémentaires de l'action (JSON)
  ipAddress    String?      @db.VarChar(45) // Adresse IP de l'utilisateur
  userAgent    String?      @db.VarChar(500) // User Agent du navigateur
  url          String?      @db.VarChar(500) // URL de la page où l'action a été effectuée
  success      Boolean      @default(true) // Si l'action a réussi
  errorMessage String?      @db.Text // Message d'erreur si l'action a échoué
  createdAt    DateTime     @default(now())

  // Relations
  User User @relation("UserActivities", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([entityType])
  @@index([entityId])
  @@index([createdAt])
  @@index([success])
  @@map("user_activities")
}

// Enum pour le statut d'un projet
enum StatutProjet {
  Planifie // Projet planifié, pas encore démarré
  EnCours // Projet en cours d'exécution
  EnPause // Projet mis en pause temporairement
  Termine // Projet terminé
  Annule // Projet annulé
}

// Enum pour le statut d'un sous-projet/tâche
enum StatutSousProjet {
  APlanifier // Tâche à planifier
  EnAttente // Tâche en attente de démarrage
  EnCours // Tâche en cours d'exécution
  EnPause // Tâche mise en pause
  Terminee // Tâche terminée
  Annulee // Tâche annulée
}

// Table pour les projets de l'association
model Projet {
  id            String       @id @default(cuid())
  titre         String       @db.VarChar(255) // Titre du projet
  description   String       @db.Text // Description détaillée du projet
  statut        StatutProjet @default(Planifie)
  dateDebut     DateTime? // Date de début prévue ou effective
  dateFin       DateTime? // Date de fin prévue ou effective
  dateFinReelle DateTime? // Date de fin réelle (si terminé)
  createdBy     String // ID de l'admin qui a créé le projet

  // Relations
  CreatedBy   User         @relation("ProjetCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  SousProjets SousProjet[] // Sous-projets/tâches du projet

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([statut])
  @@index([createdBy])
  @@index([dateDebut])
  @@index([dateFin])
  @@map("projets")
}

// Table pour les sous-projets/tâches
model SousProjet {
  id            String           @id @default(cuid())
  projetId      String // Référence au projet parent
  titre         String           @db.VarChar(255) // Titre de la tâche
  description   String           @db.Text // Description détaillée de la tâche
  statut        StatutSousProjet @default(APlanifier)
  ordre         Int              @default(0) // Ordre d'affichage dans la liste
  dateDebut     DateTime? // Date de début prévue ou effective
  dateFin       DateTime? // Date de fin prévue ou effective
  dateFinReelle DateTime? // Date de fin réelle (si terminée)

  // Relations
  Projet       Projet                  @relation(fields: [projetId], references: [id], onDelete: Cascade)
  Affectations AffectationSousProjet[] // Adhérents affectés à cette tâche
  Commentaires CommentaireTache[] // Commentaires sur l'évolution de la tâche

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projetId])
  @@index([statut])
  @@index([ordre])
  @@map("sous_projets")
}

// Table de liaison pour les affectations (many-to-many entre SousProjet et Adherent)
model AffectationSousProjet {
  id                 String    @id @default(cuid())
  sousProjetId       String // Référence au sous-projet/tâche
  adherentId         String // Référence à l'adhérent affecté
  dateAffectation    DateTime  @default(now()) // Date d'affectation
  dateFinAffectation DateTime? // Date de fin d'affectation (si l'adhérent est retiré avant la fin du projet)
  responsable        Boolean   @default(false) // Si true, l'adhérent est responsable de cette tâche

  // Relations
  SousProjet SousProjet @relation(fields: [sousProjetId], references: [id], onDelete: Cascade)
  Adherent   Adherent   @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sousProjetId, adherentId]) // Un adhérent ne peut être affecté qu'une fois à une tâche
  @@index([sousProjetId])
  @@index([adherentId])
  @@index([dateAffectation])
  @@map("affectations_sous_projets")
}

// Table pour les commentaires sur l'évolution des tâches
model CommentaireTache {
  id                    String @id @default(cuid())
  sousProjetId          String // Référence au sous-projet/tâche
  adherentId            String // Adhérent qui a fait le commentaire
  contenu               String @db.Text // Contenu du commentaire
  pourcentageAvancement Int? // Pourcentage d'avancement (0-100) si l'adhérent le précise

  // Relations
  SousProjet SousProjet @relation(fields: [sousProjetId], references: [id], onDelete: Cascade)
  Adherent   Adherent   @relation(fields: [adherentId], references: [id], onDelete: Cascade)

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sousProjetId])
  @@index([adherentId])
  @@index([createdAt])
  @@map("commentaires_taches")
}

// Modèle pour les rôles d'administration des utilisateurs
// Permet à un utilisateur d'avoir plusieurs rôles d'administration
model UserAdminRole {
  id        String    @id @default(cuid())
  userId    String
  role      AdminRole
  createdAt DateTime  @default(now())
  createdBy String // ID de l'admin qui a attribué ce rôle
  updatedAt DateTime  @updatedAt

  // Relations
  user    User @relation("UserAdminRoles", fields: [userId], references: [id], onDelete: Cascade)
  creator User @relation("UserAdminRoleCreator", fields: [createdBy], references: [id], onDelete: Restrict)

  @@unique([userId, role]) // Un utilisateur ne peut avoir qu'une seule instance de chaque rôle
  @@index([userId])
  @@index([role])
  @@index([createdBy])
  @@map("user_admin_roles")
}

// Enum pour les types de permissions
enum PermissionType {
  READ // Lecture seule
  WRITE // Écriture (création/modification)
  DELETE // Suppression
  MANAGE // Gestion complète (inclut toutes les opérations)
}

// Modèle pour les permissions dynamiques basées sur la base de données
// Permet de gérer les permissions par action/route sans rebuild de l'application
model Permission {
  id          String         @id @default(cuid())
  action      String         @db.VarChar(255) // Nom de l'action Server Action (ex: "getAllDettesInitiales")
  resource    String         @db.VarChar(100) // Ressource concernée (ex: "finances", "dettes", "paiements")
  type        PermissionType // Type de permission (READ, WRITE, DELETE, MANAGE)
  roles       String[] // Array de rôles autorisés (ex: ["ADMIN", "PRESID", "TRESOR"])
  description String?        @db.VarChar(500) // Description de la permission
  route       String?        @db.VarChar(255) // Route associée (ex: "/admin/finances/dettes")
  enabled     Boolean        @default(true) // Si false, la permission est désactivée
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  createdBy   String? // ID de l'admin qui a créé cette permission

  // Relations
  CreatedBy User? @relation("PermissionCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)

  @@unique([action, type]) // Une action ne peut avoir qu'une seule permission par type
  @@index([action])
  @@index([resource])
  @@index([type])
  @@index([enabled])
  @@index([route])
  @@map("permissions")
}
